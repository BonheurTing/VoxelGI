// Each #kernel tells which function to compile; you can have many kernels

#pragma enable_d3d11_debug_symbols
#pragma kernel VoxelDirectLighting
#pragma kernel MipmapGeneration
#pragma kernel CopyTexture3D
#pragma kernel VoxelIndirectLighting

#define ENABLE_SHADOW_SUN_BIAS 1
#define ENABLE_SHADOW_NORMAL_BIAS 1

//#define RADIANCE_POINT_SAMPLER

Texture3D<uint> RWAlbedo;
Texture3D<uint> RWNormal;
Texture3D<uint> RWEmissive;
Texture3D<uint> RWOpacity;

sampler2D ShadowDepth;

float4x4 gVoxelToWorld;
float4x4 gWorldToVoxel;
float gVoxelTextureResolution;
float gVoxelSize;

// todo enable second bounce

//------------------------------------------------------------------------------------------------------
// Util
//------------------------------------------------------------------------------------------------------

uint EncodeGbuffer(float4 value)
{
	uint res = (uint(value.x * 255.f) << 24) + (uint(value.y * 255.f) << 16)
		+ (uint(value.z * 255.f) << 8) + uint(value.w * 255.f);
	return res;
}

float4 DecodeGbuffer(uint value)
{
	float4 res = float4(0.f, 0.f, 0.f, 0.f);
	res.w = (value & 255) / 255.f;
	value = value >> 8;
	res.z = (value & 255) / 255.f;
	value = value >> 8;
	res.y = (value & 255) / 255.f;
	value = value >> 8;
	res.x = (value & 255) / 255.f;
	return res;
}

float3x3 GetTangentBasis(float3 TangentZ)
{
	float3 UpVector = abs(TangentZ.z) < 0.999 ? float3(0, 0, 1) : float3(1, 0, 0);
	float3 TangentX = normalize(cross(UpVector, TangentZ));
	float3 TangentY = cross(TangentZ, TangentX);
	return float3x3(TangentX, TangentY, TangentZ);
}

static float3 Fibonacci_Lattice_Hemisphere_1[1] =
{
	float3(0.0, 0.0, 1.0)
};

static float3 Fibonacci_Lattice_Hemisphere_4[4] =
{
	float3(-0.731585503467728, -0.670192249370187, 0.125),
	float3(0.0810458159223954, 0.923475270768781, 0.375),
	float3(0.474962433620099, -0.619504387918014, 0.625),
	float3(-0.476722366176565, 0.0843254741286256, 0.875),
};

static float3 Fibonacci_Lattice_Hemisphere_8[8] =
{
	float3(-0.735927295315164, -0.674169686362497, 0.0625),
	float3(0.0858751947674414, 0.978503551819642, 0.1875),
	float3(0.577966879673501, -0.75385544768243, 0.3125),
	float3(-0.885472495182538, 0.156627616578975, 0.4375),
	float3(0.697614586708622, 0.443765296537886, 0.5625),
	float3(-0.188520590528854, -0.701287200044783, 0.6875),
	float3(-0.26869090798331, 0.517347993102423, 0.8125),
	float3(0.326869977432545, -0.119372391503427, 0.9375),
};

static float3 Fibonacci_Lattice_Hemisphere_16[16] =
{
	float3(-0.737008746736654, -0.675160384452218, 0.03125),
	float3(0.0870406817287227, 0.991783674610648, 0.09375),
	float3(0.600965734598756, -0.783853381276229, 0.15625),
	float3(-0.960864647623557, 0.169963426793115, 0.21875),
	float3(0.80969671855586, 0.515062774290544, 0.28125),
	float3(-0.243784330107323, -0.906865556680881, 0.34375),
	float3(-0.421159310808654, 0.810916624825992, 0.40625),
	float3(0.829731504061828, -0.303016614507021, 0.46875),
	float3(-0.783119519232434, -0.323260353426092, 0.53125),
	float3(0.341047499504824, 0.72879869688516, 0.59375),
	float3(0.225822703319255, -0.71995836279995, 0.65625),
	float3(-0.601554193574072, 0.34861295112696, 0.71875),
	float3(0.609658853079947, 0.134031788622115, 0.78125),
	float3(-0.308692885622987, -0.43908386427396, 0.84375),
	float3(-0.0543268871447994, 0.419236838592646, 0.90625),
	float3(0.189662913959254, -0.159848104675922, 0.96875),
};

//------------------------------------------------------------------------------------------------------
// Generate Mipmap.
//------------------------------------------------------------------------------------------------------
/*
static float Weights[4] = {
  0.125,
  0.0625,
  0.03125,
  0.015625
};
*/
uint DstRes;
uint SrcMipLevel;
Texture3D<float4> MipmapSrc;
RWTexture3D<float4> MipmapDst;
uint MipmapDimension; // x: 0, y: 1, z: 2
#define MIPMAP_THREAD_NUM 8
#define USING_THREE_PASS 0
groupshared float4 gCache[2* MIPMAP_THREAD_NUM+1];

static float Weights[3] = {
  0.25,
  0.5,
  0.25
};

static float SampleBias[2] = {
  -0.5,
  0.5
};

uint GetCacheLoc(uint3 id)
{
	return id.x * MIPMAP_THREAD_NUM * MIPMAP_THREAD_NUM + id.y * MIPMAP_THREAD_NUM + id.z;
}

[numthreads(MIPMAP_THREAD_NUM, MIPMAP_THREAD_NUM, MIPMAP_THREAD_NUM)]
void MipmapGeneration(uint3 groupId : SV_GroupThreadID,
										uint3 dispatchId : SV_DispatchThreadID)
{
#if USING_THREE_PASS

	float4 srcColor = MipmapSrc.Load(int4(2 * dispatchId, SrcMipLevel));
	switch (MipmapDimension)
	{
	case 0: // x
		float4 srcColor0 = MipmapSrc.Load(int4(2*dispatchId+ uint3(1, 0, 0), SrcMipLevel));
		gCache[2* groupId.x] = srcColor;
		gCache[2 * groupId.x+1] = srcColor0;
		if (groupId.x >= MIPMAP_THREAD_NUM - 1)
		{
			gCache[2 * groupId.x + 2] = MipmapSrc.Load(int4(2 * dispatchId + uint3(2, 0, 0), SrcMipLevel));
		}

		GroupMemoryBarrierWithGroupSync();
		MipmapDst[dispatchId] = gCache[2 * groupId.x] * 0.25 + 
			gCache[2 * groupId.x + 1] * 0.5 + gCache[2 * groupId.x + 2] * 0.25;

		break;
	case 1: // y
		float4 srcColor1 = MipmapSrc.Load(int4(2 * dispatchId + uint3(0, 1, 0), SrcMipLevel));
		gCache[2 * groupId.y] = srcColor;
		gCache[2 * groupId.y + 1] = srcColor1;
		if (groupId.y >= MIPMAP_THREAD_NUM - 1)
		{
			gCache[2 * groupId.y + 2] = MipmapSrc.Load(int4(2 * dispatchId + uint3(0, 2, 0), SrcMipLevel));
		}

		GroupMemoryBarrierWithGroupSync();
		MipmapDst[dispatchId] = gCache[2 * groupId.y] * 0.25 +
			gCache[2 * groupId.y + 1] * 0.5 + gCache[2 * groupId.y + 2] * 0.25;

		break;
	case 2: // z
		float4 srcColor2 = MipmapSrc.Load(int4(2 * dispatchId + uint3(0, 0, 1), SrcMipLevel));
		gCache[2 * groupId.z] = srcColor;
		gCache[2 * groupId.z + 1] = srcColor2;
		if (groupId.z >= MIPMAP_THREAD_NUM - 1)
		{
			gCache[2 * groupId.z + 2] = MipmapSrc.Load(int4(2 * dispatchId + uint3(0, 0, 2), SrcMipLevel));
		}

		GroupMemoryBarrierWithGroupSync();
		MipmapDst[dispatchId] = gCache[2 * groupId.z] * 0.25 +
			gCache[2 * groupId.z + 1] * 0.5 + gCache[2 * groupId.z + 2] * 0.25;

		break;
	default:
		break;
	}
	
#else
	
	if (any(dispatchId >= DstRes)) return;

	half4 color = 0.0;

	[unroll]
	for (uint i = 0; i < 2; ++i)
	{
		[unroll]
		for (uint j = 0; j < 2; ++j)
		{
			[unroll]
			for (uint k = 0; k < 2; ++k)
			{
				float4 sampled = MipmapSrc.Load(uint4(2 * dispatchId + uint3(i, j, k), SrcMipLevel));
				color += 0.125 * sampled;
			}
		}
	}
	GroupMemoryBarrierWithGroupSync();

	MipmapDst[dispatchId] = color;
	
#endif
	
}

//------------------------------------------------------------------------------------------------------
// Copy Texture 3D.
//------------------------------------------------------------------------------------------------------

uint CopyMipLevel;
Texture3D<float4> TexSrc;
RWTexture3D<float4> TexDst;

[numthreads(8, 8, 8)]
void CopyTexture3D(uint3 id : SV_DispatchThreadID)
{
	float4 sampled = TexSrc.Load(int4(id, CopyMipLevel));
	TexDst[id.xyz] = sampled;
}

//------------------------------------------------------------------------------------------------------
// Calculate Voxel Direct Lighting.
//------------------------------------------------------------------------------------------------------

float3 SunLightColor;
float3 SunLightDir;
float SunLightIntensity;

float LightIndensityMulti = 1.0f;
float EmissiveMulti = 1.0f;

float4x4 gWorldToShadowVP;

float ShadowSunBias;
float ShadowNormalBias;

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture3D<half4> OutRadiance;

[numthreads(4,4,4)]
void VoxelDirectLighting(uint3 id : SV_DispatchThreadID)
{
	float3 voxelPos = float3(id)+float3(0.5f, 0.5f, 0.5f);
	float3 worldPos = mul(gVoxelToWorld, float4(voxelPos, 1.0f)).xyz;
	float3 voxelIrradiance = 0.f;

	float3 albedo = DecodeGbuffer(RWAlbedo[id.xyz]).xyz;
	float3 normal = DecodeGbuffer(RWNormal[id.xyz]).xyz;
	normal = (normal * 2.f) - float3(1.f, 1.f, 1.f);
	float3 emissive = DecodeGbuffer(RWEmissive[id.xyz]).xyz;
	emissive = emissive * EmissiveMulti;
	float opacity = DecodeGbuffer(RWOpacity[id.xyz]).x;

	// shadow
#if ENABLE_SHADOW_NORMAL_BIAS
	float3 shadowWorldPos = worldPos + normal * 0.5f * ShadowNormalBias * gVoxelSize;
	float4 shadowPos = mul(gWorldToShadowVP, float4(shadowWorldPos, 1.0f));
#elif ENABLE_SHADOW_SUN_BIAS
	float3 shadowWorldPos = worldPos - normalize(SunLightDir) * 0.5f * ShadowSunBias * gVoxelSize;
	float4 shadowPos = mul(gWorldToShadowVP, float4(shadowWorldPos, 1.0f));
#else
	float4 shadowPos = mul(gWorldToShadowVP, float4(worldPos, 1.f));
#endif
	shadowPos /= shadowPos.w;
	float2 shadowUV = shadowPos.xy * float2(0.5f, -0.5f) + float2(0.5f, 0.5f);
	float shadow = 1.f;
	float shadowDepth = tex2Dlod(ShadowDepth, float4(shadowUV, 0, 0)).x;
	if (shadowPos.z > shadowDepth)
	{
		shadow = 0.f;
	}

	float3 L = -SunLightDir;
	float NdotL = max(dot(normal, L), 0.05f);
	voxelIrradiance += NdotL * SunLightColor * SunLightIntensity * LightIndensityMulti * shadow;

	voxelIrradiance *= albedo;

	float3 resColor = voxelIrradiance + emissive;

	OutRadiance[id.xyz] = float4(resColor, opacity);
}


//------------------------------------------------------------------------------------------------------
// Calculate Voxel Indirect Lighting.
//------------------------------------------------------------------------------------------------------

SamplerState point_clamp_sampler;
SamplerState linear_clamp_sampler;
Texture3D<float4> VoxelLighting;

RWTexture3D<half4> OutIndirectRadiance;

float IndirectLightingMaxMipLevel;
int IndirectLightingMaxStepNum;
float IndirectLightingAlphaAtten;
float IndirectLightingScale;
float IndirectLightingConeAngle;
float IndirectLightingFirstStep;
float IndirectLightingStepScale;
int IndirectLightingMinMipLevel;

#define INDIRECT_CONE_TRACE_LOW 0
#define INDIRECT_CONE_TRACE_VERY_LOW 1

#if INDIRECT_CONE_TRACE_VERY_LOW
	#define CONE_COUNT 1
	#define Fibonacci_Lattice_Hemisphere Fibonacci_Lattice_Hemisphere_1
#elif INDIRECT_CONE_TRACE_LOW
	#define CONE_COUNT 4
	#define Fibonacci_Lattice_Hemisphere Fibonacci_Lattice_Hemisphere_4
#elif INDIRECT_CONE_TRACE_MID
	#define CONE_COUNT 8
	#define Fibonacci_Lattice_Hemisphere Fibonacci_Lattice_Hemisphere_8
#elif INDIRECT_CONE_TRACE_HIGH
	#define CONE_COUNT 16
	#define Fibonacci_Lattice_Hemisphere Fibonacci_Lattice_Hemisphere_16
#endif

float CalcMipLevel(float size)
{
	return size <= 1.0 ? size : log2(size) + 1;
}

float TextureSDF(float3 position)
{
	position = .5f - abs(position - .5f);
	return min(min(position.x, position.y), position.z);
}

float3 SquareToUniformHemisphere(float2 input)
{
	// theta = acos(1 - x), x is uniform from [0, 1],
	// so (1 - x) is also uniform from [0, 1]
	float cosTheta = input.x;
	float phi = input.y * 3.14159265 * 2;
	float r = sqrt(max(0.f, 1.f - cosTheta * cosTheta));
	return float3(r * cos(phi), r * sin(phi), cosTheta);
}

float3 CalculateIndirectIrradiance(float3 voxelPos, float3 normal)
{
	if (TextureSDF(voxelPos / gVoxelTextureResolution) < 0.0)
	{
		return float3(0.f, 0.f, 0.f);
	}

	normal = normalize(normal);
	float3 origin = voxelPos / gVoxelTextureResolution;

	float3x3 TangentBasis = GetTangentBasis(normal);
	float coneTan = tan(IndirectLightingConeAngle * 3.14159265f / 360.f);
	float offset, sampleRadius, step, ndotl;
	float3 coordinate, coneDir;
	float4 coneColor, resultColor = float4(0.f, 0.f, 0.f, 0.f);
	int coneIndex, stepNum;

	for (coneIndex = 0; coneIndex < CONE_COUNT; ++coneIndex)
	{
		coneColor = float4(0.f, 0.f, 0.f, 0.f);
		step = IndirectLightingFirstStep / gVoxelTextureResolution;
		offset = step;
		sampleRadius = offset * coneTan;
		coneDir = Fibonacci_Lattice_Hemisphere[coneIndex];
		coneDir = normalize(mul(coneDir, TangentBasis));

		coordinate = origin + offset * coneDir;
		int stepNum = 0;
		[loop]
		while (coneColor.a < 0.95f && TextureSDF(coordinate) > 0.0f && stepNum <= IndirectLightingMaxStepNum)
		{
			float mip = clamp(CalcMipLevel(sampleRadius * gVoxelTextureResolution), IndirectLightingMinMipLevel, IndirectLightingMaxMipLevel);
			float4 sampledRadiance = VoxelLighting.SampleLevel(linear_clamp_sampler, coordinate, mip);
			coneColor += (1.f - pow(coneColor.a, IndirectLightingAlphaAtten)) *  sampledRadiance;

			step *= IndirectLightingStepScale;
			offset += step;
			sampleRadius = offset * coneTan;
			coordinate = origin + offset * coneDir;
			stepNum++;
		}

		ndotl = dot(coneDir, normal);
		resultColor += coneColor * ndotl;
	}

	return resultColor.xyz;
}

[numthreads(8, 8, 8)]
void VoxelIndirectLighting(uint3 id : SV_DispatchThreadID)
{
	float3 voxelPos = float3(id)+float3(0.5f, 0.5f, 0.5f);
	float3 worldPos = mul(gVoxelToWorld, float4(voxelPos, 1.0f)).xyz;
	float3 voxelIrradiance = 0.f;

	float3 albedo = DecodeGbuffer(RWAlbedo[id.xyz]).xyz;
	float3 normal = DecodeGbuffer(RWNormal[id.xyz]).xyz;
	normal = (normal * 2.f) - float3(1.f, 1.f, 1.f);
	float opacity = DecodeGbuffer(RWOpacity[id.xyz]).x;

	float3 directColor = VoxelLighting[id.xyz].xyz;

	voxelIrradiance = CalculateIndirectIrradiance(voxelPos, normal);

	float3 resultColor = directColor + voxelIrradiance * albedo * IndirectLightingScale;

	OutIndirectRadiance[id.xyz] = float4(resultColor, opacity);
}